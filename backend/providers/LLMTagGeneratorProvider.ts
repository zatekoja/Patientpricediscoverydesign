import { BaseDataProvider } from './BaseDataProvider';
import { DataProviderOptions, DataProviderResponse } from '../interfaces/IExternalDataProvider';
import { IDocumentStore } from '../interfaces/IDocumentStore';
import { PriceData } from '../types/PriceData';

/**
 * Configuration for LLM Tag Generator Provider
 */
export interface LLMTagGeneratorConfig {
  /** LLM API endpoint URL */
  apiEndpoint: string;
  
  /** API key for authentication */
  apiKey: string;
  
  /** LLM model to use (e.g., "gpt-4", "claude-3", etc.) */
  model: string;
  
  /** System prompt for tag generation */
  systemPrompt?: string;
  
  /** Maximum tags to generate per item */
  maxTags?: number;
  
  /** Temperature for LLM generation */
  temperature?: number;
}

/**
 * Extended PriceData with LLM-generated tags
 */
export interface TaggedPriceData extends PriceData {
  tags?: string[];
  tagMetadata?: {
    generatedAt: Date;
    model: string;
    confidence?: number;
  };
}

/**
 * LLM-based External Data Provider for Tag Generation
 * 
 * This provider enriches price data with contextual tags generated by an LLM
 * to power contextual search in Typesense or other search engines.
 * 
 * Workflow:
 * 1. Receives price data from upstream providers
 * 2. Sends data to LLM for tag generation
 * 3. Adds generated tags to the data
 * 4. Stores enriched data in document store
 */
export class LLMTagGeneratorProvider extends BaseDataProvider<TaggedPriceData> {
  private llmConfig?: LLMTagGeneratorConfig;
  private sourceProvider?: BaseDataProvider<PriceData>;
  
  constructor(documentStore?: IDocumentStore<TaggedPriceData>, sourceProvider?: BaseDataProvider<PriceData>) {
    super('llm_tag_generator', documentStore);
    this.sourceProvider = sourceProvider;
  }
  
  validateConfig(config: Record<string, any>): boolean {
    const llmConfig = config as LLMTagGeneratorConfig;
    
    if (!llmConfig.apiEndpoint) {
      console.error('Missing apiEndpoint in LLM configuration');
      return false;
    }
    
    if (!llmConfig.apiKey) {
      console.error('Missing apiKey in LLM configuration');
      return false;
    }
    
    if (!llmConfig.model) {
      console.error('Missing model in LLM configuration');
      return false;
    }
    
    return true;
  }
  
  async initialize(config: Record<string, any>): Promise<void> {
    await super.initialize(config);
    this.llmConfig = {
      ...config as LLMTagGeneratorConfig,
      systemPrompt: (config as LLMTagGeneratorConfig).systemPrompt || this.getDefaultSystemPrompt(),
      maxTags: (config as LLMTagGeneratorConfig).maxTags || 10,
      temperature: (config as LLMTagGeneratorConfig).temperature || 0.3,
    };
    
    console.log(`Initialized ${this.name} with model: ${this.llmConfig.model}`);
  }
  
  async getCurrentData(options?: DataProviderOptions): Promise<DataProviderResponse<TaggedPriceData>> {
    this.ensureInitialized();
    
    // If we have a document store, query from it
    if (this.documentStore) {
      const query = await this.documentStore.query(
        { source: this.name },
        {
          limit: options?.limit || 100,
          offset: options?.offset || 0,
          sortBy: 'lastUpdated',
          sortOrder: 'desc',
        }
      );
      
      return {
        data: query,
        timestamp: new Date(),
        metadata: {
          source: this.name,
          count: query.length,
        },
      };
    }
    
    // Otherwise, get from source provider and enrich
    if (!this.sourceProvider) {
      throw new Error('No source provider or document store configured');
    }
    
    const sourceData = await this.sourceProvider.getCurrentData(options);
    const enrichedData = await this.enrichWithTags(sourceData.data);
    
    return {
      data: enrichedData,
      timestamp: new Date(),
      metadata: {
        source: this.name,
        count: enrichedData.length,
        upstream: sourceData.metadata?.source,
      },
    };
  }
  
  async getPreviousData(options?: DataProviderOptions): Promise<DataProviderResponse<TaggedPriceData>> {
    this.ensureInitialized();
    
    if (!this.documentStore) {
      throw new Error('Document store not configured');
    }
    
    const previousData = await this.documentStore.query(
      { source: this.name },
      {
        limit: options?.limit || 100,
        sortBy: 'lastUpdated',
        sortOrder: 'desc',
        offset: options?.offset || 0,
      }
    );
    
    return {
      data: previousData,
      timestamp: new Date(),
      metadata: {
        source: this.name,
        count: previousData.length,
        type: 'previous',
      },
    };
  }
  
  async getHistoricalData(options: DataProviderOptions): Promise<DataProviderResponse<TaggedPriceData>> {
    this.ensureInitialized();
    
    if (!this.documentStore) {
      throw new Error('Document store not configured');
    }
    
    let startDate: Date;
    let endDate: Date;
    
    if (options.timeWindow) {
      const dateRange = this.parseTimeWindow(options.timeWindow);
      startDate = dateRange.startDate;
      endDate = dateRange.endDate;
    } else if (options.startDate && options.endDate) {
      startDate = options.startDate;
      endDate = options.endDate;
    } else {
      throw new Error('Either timeWindow or startDate/endDate must be provided');
    }
    
    const historicalData = await this.documentStore.query(
      {
        source: this.name,
        effectiveDate: {
          $gte: startDate,
          $lte: endDate,
        },
      },
      {
        limit: options.limit || 1000,
        offset: options.offset || 0,
        sortBy: 'effectiveDate',
        sortOrder: 'desc',
      }
    );
    
    return {
      data: historicalData,
      timestamp: new Date(),
      metadata: {
        source: this.name,
        count: historicalData.length,
        type: 'historical',
        dateRange: { startDate, endDate },
      },
    };
  }
  
  /**
   * Sync data from source provider, enrich with tags, and store
   */
  async syncData(): Promise<{
    success: boolean;
    recordsProcessed: number;
    timestamp: Date;
    error?: string;
  }> {
    const timestamp = new Date();
    
    try {
      if (!this.sourceProvider) {
        throw new Error('No source provider configured for LLM tag generator');
      }
      
      // Get data from source provider
      const sourceData = await this.sourceProvider.getCurrentData();
      
      // Enrich with LLM-generated tags
      const enrichedData = await this.enrichWithTags(sourceData.data);
      
      // Store in document store if available
      if (this.documentStore && enrichedData.length > 0) {
        const items = enrichedData.map((data, index) => ({
          key: this.generateKey(data, index),
          data,
          metadata: {
            syncTimestamp: timestamp,
            source: this.name,
            upstreamSource: sourceData.metadata?.source,
          },
        }));
        
        await this.documentStore.batchPut(items);
      }
      
      this.lastSyncDate = timestamp;
      
      return {
        success: true,
        recordsProcessed: enrichedData.length,
        timestamp,
      };
    } catch (error) {
      return {
        success: false,
        recordsProcessed: 0,
        timestamp,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
  
  /**
   * Enrich price data with LLM-generated contextual tags
   */
  private async enrichWithTags(priceData: PriceData[]): Promise<TaggedPriceData[]> {
    if (!this.llmConfig) {
      throw new Error('LLM configuration not initialized');
    }
    
    const enrichedData: TaggedPriceData[] = [];
    
    // Process in batches to avoid overwhelming the LLM API
    const batchSize = 10;
    for (let i = 0; i < priceData.length; i += batchSize) {
      const batch = priceData.slice(i, i + batchSize);
      const taggedBatch = await Promise.all(
        batch.map(item => this.generateTagsForItem(item))
      );
      enrichedData.push(...taggedBatch);
    }
    
    return enrichedData;
  }
  
  /**
   * Generate contextual tags for a single price data item using LLM
   */
  private async generateTagsForItem(item: PriceData): Promise<TaggedPriceData> {
    if (!this.llmConfig) {
      throw new Error('LLM configuration not initialized');
    }
    
    try {
      const prompt = this.buildTagGenerationPrompt(item);
      const tags = await this.callLLMAPI(prompt);
      
      return {
        ...item,
        tags,
        tagMetadata: {
          generatedAt: new Date(),
          model: this.llmConfig.model,
        },
      };
    } catch (error) {
      console.error(`Failed to generate tags for item ${item.id}:`, error);
      // Return item without tags on error
      return {
        ...item,
        tags: [],
        tagMetadata: {
          generatedAt: new Date(),
          model: this.llmConfig.model,
        },
      };
    }
  }
  
  /**
   * Build a prompt for the LLM to generate contextual tags
   */
  private buildTagGenerationPrompt(item: PriceData): string {
    return `Given this healthcare price information, generate contextual tags that will help with search and discovery:

Facility: ${item.facilityName}
Procedure: ${item.procedureDescription} (Code: ${item.procedureCode})
Price: $${item.price} ${item.currency}
${item.location ? `Location: ${item.location.city}, ${item.location.state}` : ''}
${item.insurance ? `Insurance: ${item.insurance.provider}` : ''}

Generate up to ${this.llmConfig!.maxTags} relevant tags that describe:
- The type of medical procedure or service
- Body part or system involved
- Medical specialty
- Common reasons someone might need this procedure
- Related conditions or symptoms
- Type of imaging or diagnostic method (if applicable)

Return ONLY a comma-separated list of tags, no explanations.`;
  }
  
  /**
   * Call the LLM API to generate tags
   * This is a placeholder implementation - adapt to your specific LLM provider
   */
  private async callLLMAPI(prompt: string): Promise<string[]> {
    if (!this.llmConfig) {
      throw new Error('LLM configuration not initialized');
    }
    
    // Placeholder implementation
    // In production, this would call the actual LLM API (OpenAI, Anthropic, etc.)
    
    // Example for OpenAI-compatible API:
    /*
    const response = await fetch(this.llmConfig.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.llmConfig.apiKey}`,
      },
      body: JSON.stringify({
        model: this.llmConfig.model,
        messages: [
          { role: 'system', content: this.llmConfig.systemPrompt },
          { role: 'user', content: prompt },
        ],
        temperature: this.llmConfig.temperature,
        max_tokens: 100,
      }),
    });
    
    const data = await response.json();
    const tagsText = data.choices[0].message.content;
    const tags = tagsText.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0);
    return tags.slice(0, this.llmConfig.maxTags);
    */
    
    console.log(`Generating tags for prompt (placeholder): ${prompt.substring(0, 100)}...`);
    
    // Return empty array for now - implement with actual LLM API
    return [];
  }
  
  /**
   * Get default system prompt for tag generation
   */
  private getDefaultSystemPrompt(): string {
    return `You are a medical knowledge expert specializing in healthcare procedures and services. 
Your task is to generate relevant, searchable tags for healthcare price information.
Focus on creating tags that patients and healthcare consumers would use when searching for procedures.
Tags should be concise, specific, and relevant to both medical professionals and general public.`;
  }
  
  /**
   * Generate unique key for tagged price data
   */
  protected generateKey(data: TaggedPriceData, index: number): string {
    const facilityKey = data.facilityId || data.facilityName.replace(/\s+/g, '_').toLowerCase();
    const effectiveDate = data.effectiveDate instanceof Date 
      ? data.effectiveDate.toISOString().split('T')[0]
      : new Date(data.effectiveDate).toISOString().split('T')[0];
    return `${this.name}_${facilityKey}_${data.procedureCode}_${effectiveDate}`;
  }
  
  /**
   * Ensure provider is initialized before operations
   */
  private ensureInitialized(): void {
    if (!this.isInitialized || !this.llmConfig) {
      throw new Error(`Provider ${this.name} is not initialized. Call initialize() first.`);
    }
  }
  
  /**
   * Set the source provider to pull data from
   */
  setSourceProvider(provider: BaseDataProvider<PriceData>): void {
    this.sourceProvider = provider;
  }
}
