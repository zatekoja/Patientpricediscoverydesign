import { BaseDataProvider } from './BaseDataProvider';
import { DataProviderOptions, DataProviderResponse } from '../interfaces/IExternalDataProvider';
import { IDocumentStore } from '../interfaces/IDocumentStore';
import { IProviderStateStore } from '../interfaces/IProviderStateStore';
import { PriceData } from '../types/PriceData';
import { recordProviderDataMetrics, recordProviderSyncMetrics, recordTagGeneration } from '../observability/metrics';
import { trace, SpanStatusCode } from '@opentelemetry/api';

/**
 * Configuration for LLM Tag Generator Provider
 */
export interface LLMTagGeneratorConfig {
  /** LLM API endpoint URL */
  apiEndpoint: string;
  
  /** API key for authentication */
  apiKey: string;
  
  /** LLM model to use (e.g., "gpt-4", "claude-3", etc.) */
  model: string;
  
  /** System prompt for tag generation */
  systemPrompt?: string;
  
  /** Maximum tags to generate per item */
  maxTags?: number;
  
  /** Temperature for LLM generation */
  temperature?: number;
}

/**
 * Extended PriceData with LLM-generated tags
 */
export interface TaggedPriceData extends PriceData {
  tags?: string[];
  tagMetadata?: {
    generatedAt: Date;
    model: string;
    confidence?: number;
  };
}

/**
 * LLM-based External Data Provider for Tag Generation
 * 
 * This provider enriches price data with contextual tags generated by an LLM
 * to power contextual search in Typesense or other search engines.
 * 
 * Workflow:
 * 1. Receives price data from upstream providers
 * 2. Sends data to LLM for tag generation
 * 3. Adds generated tags to the data
 * 4. Stores enriched data in document store
 */
export class LLMTagGeneratorProvider extends BaseDataProvider<TaggedPriceData> {
  private llmConfig?: LLMTagGeneratorConfig;
  private sourceProvider?: BaseDataProvider<PriceData>;
  
  constructor(
    documentStore?: IDocumentStore<TaggedPriceData>,
    sourceProvider?: BaseDataProvider<PriceData>,
    stateStore?: IProviderStateStore
  ) {
    super('llm_tag_generator', documentStore, stateStore);
    this.sourceProvider = sourceProvider;
  }
  
  validateConfig(config: Record<string, any>): boolean {
    const llmConfig = config as LLMTagGeneratorConfig;
    
    if (!llmConfig.apiEndpoint) {
      console.error('Missing apiEndpoint in LLM configuration');
      return false;
    }
    
    if (!llmConfig.apiKey) {
      console.error('Missing apiKey in LLM configuration');
      return false;
    }
    
    if (!llmConfig.model) {
      console.error('Missing model in LLM configuration');
      return false;
    }

    // Warn if using placeholder values
    if (llmConfig.apiEndpoint === 'placeholder' || llmConfig.apiKey === 'placeholder') {
      console.warn('⚠️  LLM configuration appears to use placeholder values.');
      console.warn('⚠️  Tag generation will return empty tags until a real LLM API is configured.');
      console.warn('⚠️  Please update apiEndpoint and apiKey in the configuration to use actual LLM services.');
    }
    
    return true;
  }
  
  async initialize(config: Record<string, any>): Promise<void> {
    await super.initialize(config);
    this.llmConfig = {
      ...config as LLMTagGeneratorConfig,
      systemPrompt: (config as LLMTagGeneratorConfig).systemPrompt || this.getDefaultSystemPrompt(),
      maxTags: (config as LLMTagGeneratorConfig).maxTags || 10,
      temperature: (config as LLMTagGeneratorConfig).temperature || 0.3,
    };
    
    console.log(`Initialized ${this.name} with model: ${this.llmConfig.model}`);
  }
  
  async getCurrentData(options?: DataProviderOptions): Promise<DataProviderResponse<TaggedPriceData>> {
    this.ensureInitialized();
    
    // If we have a document store, query from it
    if (this.documentStore) {
      const query = await this.documentStore.query(
        { source: this.name },
        {
          limit: options?.limit || 100,
          offset: options?.offset || 0,
          sortBy: 'lastUpdated',
          sortOrder: 'desc',
        }
      );
      
      return {
        data: query,
        timestamp: new Date(),
        metadata: {
          source: this.name,
          count: query.length,
        },
      };
    }
    
    // Otherwise, get from source provider and enrich
    if (!this.sourceProvider) {
      throw new Error('No source provider or document store configured');
    }
    
    const sourceData = await this.sourceProvider.getCurrentData(options);
    const enrichedData = await this.enrichWithTags(sourceData.data);
    
    return {
      data: enrichedData,
      timestamp: new Date(),
      metadata: {
        source: this.name,
        count: enrichedData.length,
        upstream: sourceData.metadata?.source,
      },
    };
  }
  
  async getPreviousData(options?: DataProviderOptions): Promise<DataProviderResponse<TaggedPriceData>> {
    this.ensureInitialized();
    
    if (!this.documentStore) {
      throw new Error('Document store not configured');
    }

    if (!this.previousBatchId) {
      return {
        data: [],
        timestamp: new Date(),
        metadata: {
          source: this.name,
          count: 0,
          type: 'previous',
          message: 'No previous batch available',
        },
      };
    }
    
    const previousData = await this.documentStore.query(
      { source: this.name, batchId: this.previousBatchId },
      {
        limit: options?.limit || 100,
        sortBy: 'lastUpdated',
        sortOrder: 'desc',
        offset: options?.offset || 0,
      }
    );
    
    return {
      data: previousData,
      timestamp: new Date(),
      metadata: {
        source: this.name,
        count: previousData.length,
        type: 'previous',
      },
    };
  }
  
  async getHistoricalData(options: DataProviderOptions): Promise<DataProviderResponse<TaggedPriceData>> {
    this.ensureInitialized();
    
    if (!this.documentStore) {
      throw new Error('Document store not configured');
    }
    
    let startDate: Date;
    let endDate: Date;
    
    if (options.timeWindow) {
      const dateRange = this.parseTimeWindow(options.timeWindow);
      startDate = dateRange.startDate;
      endDate = dateRange.endDate;
    } else if (options.startDate && options.endDate) {
      startDate = options.startDate;
      endDate = options.endDate;
    } else {
      throw new Error('Either timeWindow or startDate/endDate must be provided');
    }
    
    const historicalData = await this.documentStore.query(
      {
        source: this.name,
        effectiveDate: {
          $gte: startDate,
          $lte: endDate,
        },
      },
      {
        limit: options.limit || 1000,
        offset: options.offset || 0,
        sortBy: 'effectiveDate',
        sortOrder: 'desc',
      }
    );
    
    return {
      data: historicalData,
      timestamp: new Date(),
      metadata: {
        source: this.name,
        count: historicalData.length,
        type: 'historical',
        dateRange: { startDate, endDate },
      },
    };
  }
  
  /**
   * Sync data from source provider, enrich with tags, and store
   */
  async syncData(): Promise<{
    success: boolean;
    recordsProcessed: number;
    timestamp: Date;
    error?: string;
  }> {
    const tracer = trace.getTracer('patient-price-discovery-provider');
    return tracer.startActiveSpan(
      'provider.sync',
      { attributes: { provider: this.name } },
      async (span) => {
        const startTime = Date.now();
        const timestamp = new Date();
        const batchId = timestamp.toISOString();
        span.setAttribute('batch_id', batchId);
        
        try {
          if (!this.sourceProvider) {
            throw new Error('No source provider configured for LLM tag generator');
          }
          
          // Get data from source provider
          const sourceData = await this.sourceProvider.getCurrentData();
          
          // Enrich with LLM-generated tags
          const enrichedData = await this.enrichWithTags(sourceData.data);
          const dataWithSync = enrichedData.map((data) =>
            this.attachSyncMetadata(data, batchId, timestamp)
          );

          recordProviderDataMetrics({ provider: this.name, records: dataWithSync });
          
          // Store in document store if available
          if (this.documentStore && dataWithSync.length > 0) {
            await tracer.startActiveSpan(
              'provider.store_batch',
              {
                attributes: {
                  provider: this.name,
                  batch_id: batchId,
                  records: dataWithSync.length,
                },
              },
              async (storeSpan) => {
                try {
                  const items = dataWithSync.map((data, index) => ({
                    key: this.generateKey(data, index),
                    data,
                    metadata: {
                      syncTimestamp: timestamp,
                      source: this.name,
                      upstreamSource: sourceData.metadata?.source,
                      batchId,
                    },
                  }));
                  await this.documentStore!.batchPut(items);
                  storeSpan.setStatus({ code: SpanStatusCode.OK });
                } catch (error) {
                  storeSpan.recordException(error as Error);
                  storeSpan.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: error instanceof Error ? error.message : 'Unknown error',
                  });
                  throw error;
                } finally {
                  storeSpan.end();
                }
              }
            );
          }
          
          this.previousBatchId = this.lastBatchId;
          this.lastBatchId = batchId;
          this.lastSyncDate = timestamp;
          await this.persistState();
          recordProviderSyncMetrics({
            provider: this.name,
            success: true,
            recordsProcessed: dataWithSync.length,
            durationMs: Date.now() - startTime,
            timestamp,
          });
          
          span.setAttribute('records_processed', dataWithSync.length);
          span.setStatus({ code: SpanStatusCode.OK });
          return {
            success: true,
            recordsProcessed: dataWithSync.length,
            timestamp,
          };
        } catch (error) {
          recordProviderSyncMetrics({
            provider: this.name,
            success: false,
            recordsProcessed: 0,
            durationMs: Date.now() - startTime,
            timestamp,
          });
          span.recordException(error as Error);
          span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error instanceof Error ? error.message : 'Unknown error',
          });
          return {
            success: false,
            recordsProcessed: 0,
            timestamp,
            error: error instanceof Error ? error.message : 'Unknown error',
          };
        } finally {
          span.end();
        }
      }
    );
  }
  
  /**
   * Enrich price data with LLM-generated contextual tags
   */
  private async enrichWithTags(priceData: PriceData[]): Promise<TaggedPriceData[]> {
    if (!this.llmConfig) {
      throw new Error('LLM configuration not initialized');
    }
    
    const enrichedData: TaggedPriceData[] = [];
    
    // Process in batches to avoid overwhelming the LLM API
    const batchSize = 10;
    for (let i = 0; i < priceData.length; i += batchSize) {
      const batch = priceData.slice(i, i + batchSize);
      const tracer = trace.getTracer('patient-price-discovery-provider');
      const taggedBatch = await tracer.startActiveSpan(
        'provider.tagging.batch',
        {
          attributes: {
            provider: this.name,
            batch_size: batch.length,
          },
        },
        async (span) => {
          try {
            const results = await Promise.all(
              batch.map((item) => this.generateTagsForItem(item))
            );
            span.setAttribute('records', results.length);
            span.setStatus({ code: SpanStatusCode.OK });
            return results;
          } catch (error) {
            span.recordException(error as Error);
            span.setStatus({
              code: SpanStatusCode.ERROR,
              message: error instanceof Error ? error.message : 'Unknown error',
            });
            throw error;
          } finally {
            span.end();
          }
        }
      );
      enrichedData.push(...taggedBatch);
    }
    
    return enrichedData;
  }
  
  /**
   * Generate contextual tags for a single price data item using LLM
   */
  private async generateTagsForItem(item: PriceData): Promise<TaggedPriceData> {
    if (!this.llmConfig) {
      throw new Error('LLM configuration not initialized');
    }
    
    const tracer = trace.getTracer('patient-price-discovery-provider');
    return tracer.startActiveSpan(
      'provider.tagging.item',
      {
        attributes: {
          provider: this.name,
          item_id: item.id,
        },
      },
      async (span) => {
        const startTime = Date.now();
        try {
          const prompt = this.buildTagGenerationPrompt(item);
          const existingTags = item.tags ?? [];
          const llmTags = await this.callLLMAPI(prompt);
          const tags = this.mergeTags(existingTags, llmTags);
          recordTagGeneration({
            provider: this.name,
            durationMs: Date.now() - startTime,
            tags: llmTags.length,
            success: true,
          });
          span.setAttribute('tags_generated', llmTags.length);
          span.setStatus({ code: SpanStatusCode.OK });
          
          return {
            ...item,
            source: this.name,
            lastUpdated: new Date(),
            tags,
            tagMetadata: {
              ...(item.tagMetadata ?? {}),
              generatedAt: new Date(),
              model: this.llmConfig?.model ?? 'unknown',
            },
            metadata: {
              ...(item.metadata ?? {}),
              upstreamSource: item.source,
            },
          };
        } catch (error) {
          console.error(`Failed to generate tags for item ${item.id}:`, error);
          recordTagGeneration({
            provider: this.name,
            durationMs: Date.now() - startTime,
            tags: 0,
            success: false,
          });
          span.recordException(error as Error);
          span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error instanceof Error ? error.message : 'Unknown error',
          });
          // Return item without tags on error
          return {
            ...item,
            source: this.name,
            lastUpdated: new Date(),
            tags: item.tags ?? [],
            tagMetadata: {
              ...(item.tagMetadata ?? {}),
              generatedAt: new Date(),
              model: this.llmConfig?.model ?? 'unknown',
            },
            metadata: {
              ...(item.metadata ?? {}),
              upstreamSource: item.source,
            },
          };
        } finally {
          span.end();
        }
      }
    );
  }
  
  /**
   * Build a prompt for the LLM to generate contextual tags
   */
  private buildTagGenerationPrompt(item: PriceData): string {
    return `Given this healthcare price information, generate contextual tags that will help with search and discovery:

Facility: ${item.facilityName}
Procedure: ${item.procedureDescription} (Code: ${item.procedureCode})
Price: $${item.price} ${item.currency}
${item.location ? `Location: ${item.location.city}, ${item.location.state}` : ''}
${item.insurance ? `Insurance: ${item.insurance.provider}` : ''}
${item.tags && item.tags.length > 0 ? `Existing tags: ${item.tags.join(', ')}` : ''}

Generate up to ${this.llmConfig!.maxTags} relevant tags that describe:
- The type of medical procedure or service
- Body part or system involved
- Medical specialty
- Common reasons someone might need this procedure
- Related conditions or symptoms
- Type of imaging or diagnostic method (if applicable)

Return ONLY a comma-separated list of tags, no explanations.`;
  }

  private mergeTags(existing: string[], incoming: string[]): string[] {
    const merged = new Set<string>();
    for (const tag of existing) {
      if (tag) {
        merged.add(tag);
      }
    }
    for (const tag of incoming) {
      if (tag) {
        merged.add(tag);
      }
    }
    return Array.from(merged);
  }
  
  /**
   * Call the LLM API to generate tags
   * This is a placeholder implementation - adapt to your specific LLM provider
   */
  private async callLLMAPI(prompt: string): Promise<string[]> {
    if (!this.llmConfig) {
      throw new Error('LLM configuration not initialized');
    }
    
    // Check for placeholder configuration
    const isPlaceholder = 
      this.llmConfig.apiEndpoint === 'placeholder' || 
      this.llmConfig.apiKey === 'placeholder' ||
      this.llmConfig.apiEndpoint.includes('example.com') ||
      !this.llmConfig.apiEndpoint.startsWith('http');

    if (isPlaceholder) {
      console.warn('⚠️  LLM API not properly configured - returning empty tags.');
      console.warn('⚠️  Configure a real LLM endpoint to enable tag generation.');
      return [];
    }
    
    // Placeholder implementation for actual LLM API integration
    // In production, this would call the actual LLM API (OpenAI, Anthropic, etc.)
    
    // Example for OpenAI-compatible API:
    /*
    try {
      const response = await fetch(this.llmConfig.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.llmConfig.apiKey}`,
        },
        body: JSON.stringify({
          model: this.llmConfig.model,
          messages: [
            { role: 'system', content: this.llmConfig.systemPrompt },
            { role: 'user', content: prompt },
          ],
          temperature: this.llmConfig.temperature,
          max_tokens: 100,
        }),
      });
      
      if (!response.ok) {
        throw new Error(`LLM API error: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      const tagsText = data.choices[0].message.content;
      const tags = tagsText.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0);
      return tags.slice(0, this.llmConfig.maxTags);
    } catch (error) {
      console.error('LLM API call failed:', error);
      throw error;
    }
    */
    
    console.log(`Generating tags for prompt (placeholder): ${prompt.substring(0, 100)}...`);
    
    // WARNING: This is a placeholder implementation
    // In production, implement actual LLM API calls
    console.warn('LLM API not implemented - returning empty tags. Implement callLLMAPI() for production use.');
    
    // Return empty array for now - implement with actual LLM API
    return [];
  }
  
  /**
   * Get default system prompt for tag generation
   */
  private getDefaultSystemPrompt(): string {
    return `You are a medical knowledge expert specializing in healthcare procedures and services. 
Your task is to generate relevant, searchable tags for healthcare price information.
Focus on creating tags that patients and healthcare consumers would use when searching for procedures.
Tags should be concise, specific, and relevant to both medical professionals and general public.`;
  }
  
  /**
   * Generate unique key for tagged price data
   */
  protected generateKey(data: TaggedPriceData, index: number): string {
    const facilityKey = data.facilityId || (data.facilityName || 'unknown').replace(/\s+/g, '_').toLowerCase();
    const effectiveDate = data.effectiveDate instanceof Date 
      ? data.effectiveDate.toISOString().split('T')[0]
      : new Date(data.effectiveDate).toISOString().split('T')[0];
    return `${this.name}_${facilityKey}_${data.procedureCode}_${effectiveDate}`;
  }
  
  /**
   * Ensure provider is initialized before operations
   */
  private ensureInitialized(): void {
    if (!this.isInitialized || !this.llmConfig) {
      throw new Error(`Provider ${this.name} is not initialized. Call initialize() first.`);
    }
  }
  
  /**
   * Set the source provider to pull data from
   */
  setSourceProvider(provider: BaseDataProvider<PriceData>): void {
    this.sourceProvider = provider;
  }
  
  /**
   * Get the document store (for workflow integration)
   */
  getDocumentStore(): IDocumentStore<TaggedPriceData> | undefined {
    return this.documentStore;
  }
}
