package entities

import "strings"

const (
	MaxTermsPerField = 10
	MaxTermLength    = 100
)

// SearchConcepts holds search-oriented concept fields generated by LLM enrichment.
type SearchConcepts struct {
	Conditions    []string `json:"conditions"`
	Symptoms      []string `json:"symptoms"`
	LayTerms      []string `json:"lay_terms"`
	Synonyms      []string `json:"synonyms"`
	Specialties   []string `json:"specialties"`
	FacilityTypes []string `json:"facility_types"`
	IntentTags    []string `json:"intent_tags"`
}

// Validate normalizes all terms (lowercase, trim, dedup) and enforces length limits.
func (sc *SearchConcepts) Validate() error {
	sc.Conditions = sanitizeTerms(sc.Conditions)
	sc.Symptoms = sanitizeTerms(sc.Symptoms)
	sc.LayTerms = sanitizeTerms(sc.LayTerms)
	sc.Synonyms = sanitizeTerms(sc.Synonyms)
	sc.Specialties = sanitizeTerms(sc.Specialties)
	sc.FacilityTypes = sanitizeTerms(sc.FacilityTypes)
	sc.IntentTags = sanitizeTerms(sc.IntentTags)
	return nil
}

// AllTerms returns a flattened, deduplicated list of all terms across all fields.
func (sc *SearchConcepts) AllTerms() []string {
	if sc == nil {
		return nil
	}

	seen := make(map[string]struct{})
	var result []string

	for _, terms := range [][]string{
		sc.Conditions, sc.Symptoms, sc.LayTerms, sc.Synonyms,
		sc.Specialties, sc.FacilityTypes, sc.IntentTags,
	} {
		for _, t := range terms {
			if _, ok := seen[t]; !ok {
				seen[t] = struct{}{}
				result = append(result, t)
			}
		}
	}

	return result
}

// MergeSearchConcepts combines two SearchConcepts, deduplicating terms.
func MergeSearchConcepts(a, b *SearchConcepts) *SearchConcepts {
	if a == nil && b == nil {
		return &SearchConcepts{}
	}
	if a == nil {
		cpy := *b
		return &cpy
	}
	if b == nil {
		cpy := *a
		return &cpy
	}

	return &SearchConcepts{
		Conditions:    mergeDedup(a.Conditions, b.Conditions),
		Symptoms:      mergeDedup(a.Symptoms, b.Symptoms),
		LayTerms:      mergeDedup(a.LayTerms, b.LayTerms),
		Synonyms:      mergeDedup(a.Synonyms, b.Synonyms),
		Specialties:   mergeDedup(a.Specialties, b.Specialties),
		FacilityTypes: mergeDedup(a.FacilityTypes, b.FacilityTypes),
		IntentTags:    mergeDedup(a.IntentTags, b.IntentTags),
	}
}

func sanitizeTerms(terms []string) []string {
	seen := make(map[string]struct{})
	var result []string

	for _, t := range terms {
		t = strings.ToLower(strings.TrimSpace(t))
		if t == "" {
			continue
		}
		if len(t) > MaxTermLength {
			t = t[:MaxTermLength]
		}
		if _, ok := seen[t]; ok {
			continue
		}
		seen[t] = struct{}{}
		result = append(result, t)
		if len(result) >= MaxTermsPerField {
			break
		}
	}

	return result
}

func mergeDedup(a, b []string) []string {
	seen := make(map[string]struct{})
	var result []string

	for _, s := range a {
		if _, ok := seen[s]; !ok {
			seen[s] = struct{}{}
			result = append(result, s)
		}
	}
	for _, s := range b {
		if _, ok := seen[s]; !ok {
			seen[s] = struct{}{}
			result = append(result, s)
		}
	}

	return result
}
