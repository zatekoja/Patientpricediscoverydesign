package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"math"
	"time"

	"github.com/zatekoja/Patientpricediscoverydesign/backend/internal/domain/entities"
	"github.com/zatekoja/Patientpricediscoverydesign/backend/internal/domain/repositories"
	"github.com/zatekoja/Patientpricediscoverydesign/backend/internal/graphql/generated"
	"github.com/zatekoja/Patientpricediscoverydesign/backend/internal/graphql/loaders"
)

// Facility is the resolver for the facility field.
func (r *appointmentResolver) Facility(ctx context.Context, obj *entities.Appointment) (*entities.Facility, error) {
	return loaders.For(ctx).FacilityLoader.Load(ctx, obj.FacilityID)()
}

// Procedure is the resolver for the procedure field.
func (r *appointmentResolver) Procedure(ctx context.Context, obj *entities.Appointment) (*entities.Procedure, error) {
	// We need the procedure at this facility to get price/context
	// First get global procedure using DataLoader
	p, err := loaders.For(ctx).ProcedureLoader.Load(ctx, obj.ProcedureID)()
	if err != nil {
		return nil, fmt.Errorf("procedure not found: %w", err)
	}

	// Then try to get pricing context from FacilityProcedure
	// Note: facilityProcedureRepo.GetByFacilityAndProcedure is not yet dataloaded,
	// but it's less critical as it's a specific pair.
	fp, err := r.facilityProcedureRepo.GetByFacilityAndProcedure(ctx, obj.FacilityID, obj.ProcedureID)
	if err == nil {
		// Return a copy to avoid mutating the cached global procedure
		pCopy := *p
		pCopy.FacilityID = fp.FacilityID
		pCopy.Price = fp.Price
		pCopy.Duration = fp.EstimatedDuration
		return &pCopy, nil
	}

	return p, nil
}

// ProviderName is the resolver for the providerName field.
func (r *appointmentResolver) ProviderName(ctx context.Context, obj *entities.Appointment) (string, error) {
	// Return default - would come from provider data
	return "Dr. Provider", nil
}

// AppointmentDate is the resolver for the appointmentDate field.
func (r *appointmentResolver) AppointmentDate(ctx context.Context, obj *entities.Appointment) (string, error) {
	return obj.ScheduledAt.Format(time.RFC3339), nil
}

// Duration is the resolver for the duration field.
func (r *appointmentResolver) Duration(ctx context.Context, obj *entities.Appointment) (int, error) {
	// Default 30 minutes - would come from procedure
	return 30, nil
}

// Price is the resolver for the price field.
func (r *appointmentResolver) Price(ctx context.Context, obj *entities.Appointment) (float64, error) {
	fp, err := r.facilityProcedureRepo.GetByFacilityAndProcedure(ctx, obj.FacilityID, obj.ProcedureID)
	if err != nil {
		return 0, nil
	}
	return fp.Price, nil
}

// InsuranceProvider is the resolver for the insuranceProvider field.
func (r *appointmentResolver) InsuranceProvider(ctx context.Context, obj *entities.Appointment) (*entities.InsuranceProvider, error) {
	if obj.InsuranceProvider == "" {
		return nil, nil
	}
	// Try as ID first
	provider, err := r.insuranceRepo.GetByID(ctx, obj.InsuranceProvider)
	if err == nil {
		return provider, nil
	}
	// Fallback to searching by code/name if needed (TODO)
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *appointmentResolver) CreatedAt(ctx context.Context, obj *entities.Appointment) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// FacilityType is the resolver for the facilityType field.
func (r *facilityResolver) FacilityType(ctx context.Context, obj *entities.Facility) (generated.FacilityType, error) {
	return generated.FacilityType(obj.FacilityType), nil
}

// Contact is the resolver for the contact field.
func (r *facilityResolver) Contact(ctx context.Context, obj *entities.Facility) (*generated.Contact, error) {
	return &generated.Contact{
		Phone:   obj.PhoneNumber,
		Email:   &obj.Email,
		Website: &obj.Website,
	}, nil
}

// AcceptsNewPatients is the resolver for the acceptsNewPatients field.
func (r *facilityResolver) AcceptsNewPatients(ctx context.Context, obj *entities.Facility) (bool, error) {
	// Default to true if not explicitly set
	return true, nil
}

// HasEmergency is the resolver for the hasEmergency field.
func (r *facilityResolver) HasEmergency(ctx context.Context, obj *entities.Facility) (bool, error) {
	// Check facility type for emergency capability
	return obj.FacilityType == "hospital" || obj.FacilityType == "urgent_care", nil
}

// HasParking is the resolver for the hasParking field.
func (r *facilityResolver) HasParking(ctx context.Context, obj *entities.Facility) (bool, error) {
	// Default to true - this would come from facility amenities in real implementation
	return true, nil
}

// WheelchairAccessible is the resolver for the wheelchairAccessible field.
func (r *facilityResolver) WheelchairAccessible(ctx context.Context, obj *entities.Facility) (bool, error) {
	// Default to true - this would come from facility amenities in real implementation
	return true, nil
}

// PriceRange is the resolver for the priceRange field.
func (r *facilityResolver) PriceRange(ctx context.Context, obj *entities.Facility) (*generated.PriceRange, error) {
	fps, err := r.facilityProcedureRepo.ListByFacility(ctx, obj.ID)
	if err != nil || len(fps) == 0 {
		return nil, nil
	}

	var min, max, sum float64
	min = fps[0].Price
	max = fps[0].Price
	for _, fp := range fps {
		if fp.Price < min {
			min = fp.Price
		}
		if fp.Price > max {
			max = fp.Price
		}
		sum += fp.Price
	}

	return &generated.PriceRange{
		Min: min,
		Max: max,
		Avg: sum / float64(len(fps)),
	}, nil
}

// InsuranceProviders is the resolver for the insuranceProviders field.
func (r *facilityResolver) InsuranceProviders(ctx context.Context, obj *entities.Facility) ([]*entities.InsuranceProvider, error) {
	return r.insuranceRepo.GetFacilityInsurance(ctx, obj.ID)
}

// Specialties is the resolver for the specialties field.
func (r *facilityResolver) Specialties(ctx context.Context, obj *entities.Facility) ([]*generated.Specialty, error) {
	// Return empty list for now - would query specialties in full implementation
	return []*generated.Specialty{}, nil
}

// Procedures is the resolver for the procedures field.
func (r *facilityResolver) Procedures(ctx context.Context, obj *entities.Facility, limit *int, offset *int) (*generated.ProcedureConnection, error) {
	// Fetch facility procedures (pricing info)
	fps, err := r.facilityProcedureRepo.ListByFacility(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch facility procedures: %w", err)
	}

	// Apply limit and offset if provided
	start := 0
	if offset != nil {
		start = *offset
	}
	if start > len(fps) {
		start = len(fps)
	}

	end := len(fps)
	if limit != nil {
		end = start + *limit
		if end > len(fps) {
			end = len(fps)
		}
	}

	pagedFps := fps[start:end]

	// Extract IDs for batch fetching using DataLoader
	nodes := make([]*entities.Procedure, 0, len(pagedFps))
	for _, fp := range pagedFps {
		// Fetch global procedure info using DataLoader
		p, err := loaders.For(ctx).ProcedureLoader.Load(ctx, fp.ProcedureID)()
		if err != nil {
			// Skip if procedure not found
			continue
		}

		// Create a copy to avoid side effects if the same procedure is in multiple results
		pCopy := *p
		pCopy.FacilityID = obj.ID
		pCopy.Price = fp.Price
		pCopy.Duration = fp.EstimatedDuration

		nodes = append(nodes, &pCopy)
	}

	return &generated.ProcedureConnection{
		Nodes: nodes,
		PageInfo: &generated.PageInfo{
			HasNextPage:     end < len(fps),
			HasPreviousPage: start > 0,
		},
		TotalCount: len(fps),
	}, nil
}

// LanguagesSpoken is the resolver for the languagesSpoken field.
func (r *facilityResolver) LanguagesSpoken(ctx context.Context, obj *entities.Facility) ([]string, error) {
	// Default to English - would come from facility data in real implementation
	return []string{"English"}, nil
}

// AvgWaitTime is the resolver for the avgWaitTime field.
func (r *facilityResolver) AvgWaitTime(ctx context.Context, obj *entities.Facility) (*int, error) {
	// Return nil for now - would be calculated from appointments
	return nil, nil
}

// NextAvailableSlot is the resolver for the nextAvailableSlot field.
func (r *facilityResolver) NextAvailableSlot(ctx context.Context, obj *entities.Facility) (*string, error) {
	// Return nil for now - would query availability
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *facilityResolver) CreatedAt(ctx context.Context, obj *entities.Facility) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *facilityResolver) UpdatedAt(ctx context.Context, obj *entities.Facility) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// Facilities is the resolver for the facilities field.
func (r *facilitySearchResultResolver) Facilities(ctx context.Context, obj *entities.GraphQLFacilitySearchResult) ([]*entities.Facility, error) {
	return obj.FacilitiesData, nil
}

// Facets is the resolver for the facets field.
func (r *facilitySearchResultResolver) Facets(ctx context.Context, obj *entities.GraphQLFacilitySearchResult) (*entities.SearchFacets, error) {
	return obj.FacetsData, nil
}

// Pagination is the resolver for the pagination field.
func (r *facilitySearchResultResolver) Pagination(ctx context.Context, obj *entities.GraphQLFacilitySearchResult) (*entities.PaginationInfo, error) {
	return obj.PaginationData, nil
}

// TotalCount is the resolver for the totalCount field.
func (r *facilitySearchResultResolver) TotalCount(ctx context.Context, obj *entities.GraphQLFacilitySearchResult) (int, error) {
	return obj.TotalCountValue, nil
}

// SearchTime is the resolver for the searchTime field.
func (r *facilitySearchResultResolver) SearchTime(ctx context.Context, obj *entities.GraphQLFacilitySearchResult) (float64, error) {
	return obj.SearchTimeMs, nil
}

// ProviderType is the resolver for the providerType field.
func (r *insuranceProviderResolver) ProviderType(ctx context.Context, obj *entities.InsuranceProvider) (generated.InsuranceType, error) {
	// Default to PPO - would come from entity data in real implementation
	return generated.InsuranceTypePpo, nil
}

// CoverageStates is the resolver for the coverageStates field.
func (r *insuranceProviderResolver) CoverageStates(ctx context.Context, obj *entities.InsuranceProvider) ([]string, error) {
	// Return empty for now - would come from entity relationships
	return []string{}, nil
}

// FacilitiesCount is the resolver for the facilitiesCount field.
func (r *insuranceProviderResolver) FacilitiesCount(ctx context.Context, obj *entities.InsuranceProvider) (int, error) {
	// Return 0 for now - would be counted from facility_insurance table
	return 0, nil
}

// ProceduresCount is the resolver for the proceduresCount field.
func (r *insuranceProviderResolver) ProceduresCount(ctx context.Context, obj *entities.InsuranceProvider) (int, error) {
	// Return 0 for now - would be counted from procedure coverage
	return 0, nil
}

// Category is the resolver for the category field.
func (r *procedureResolver) Category(ctx context.Context, obj *entities.Procedure) (generated.ProcedureCategory, error) {
	return generated.ProcedureCategory(obj.Category), nil
}

// Price is the resolver for the price field.
func (r *procedureResolver) Price(ctx context.Context, obj *entities.Procedure) (float64, error) {
	return obj.Price, nil
}

// Duration is the resolver for the duration field.
func (r *procedureResolver) Duration(ctx context.Context, obj *entities.Procedure) (int, error) {
	return obj.Duration, nil
}

// RequiresReferral is the resolver for the requiresReferral field.
func (r *procedureResolver) RequiresReferral(ctx context.Context, obj *entities.Procedure) (bool, error) {
	// Default to false - would come from procedure metadata
	return false, nil
}

// PreparationRequired is the resolver for the preparationRequired field.
func (r *procedureResolver) PreparationRequired(ctx context.Context, obj *entities.Procedure) (bool, error) {
	// Default to false - would come from procedure metadata
	return false, nil
}

// Facility is the resolver for the facility field.
func (r *procedureResolver) Facility(ctx context.Context, obj *entities.Procedure) (*entities.Facility, error) {
	if obj.FacilityID == "" {
		return nil, fmt.Errorf("facility context missing for procedure")
	}
	return loaders.For(ctx).FacilityLoader.Load(ctx, obj.FacilityID)()
}

// InsuranceCoverage is the resolver for the insuranceCoverage field.
func (r *procedureResolver) InsuranceCoverage(ctx context.Context, obj *entities.Procedure) ([]*entities.InsuranceProvider, error) {
	if obj.FacilityID == "" {
		return []*entities.InsuranceProvider{}, nil
	}
	// For a procedure at a facility, coverage is typically the facility's accepted insurance
	return r.insuranceRepo.GetFacilityInsurance(ctx, obj.FacilityID)
}

// Facility is the resolver for the facility field.
func (r *queryResolver) Facility(ctx context.Context, id string) (*entities.Facility, error) {
	// Use DataLoader which handles batching and can be wrapped with caching if needed
	// For now, it will use the batch fetch GetByIDs
	return loaders.For(ctx).FacilityLoader.Load(ctx, id)()
}

// Facilities is the resolver for the facilities field.
func (r *queryResolver) Facilities(ctx context.Context, filter generated.FacilitySearchInput) (*entities.GraphQLFacilitySearchResult, error) {
	// Build search params from filter
	params := repositories.SearchParams{
		Latitude:  filter.Location.Latitude,
		Longitude: filter.Location.Longitude,
		RadiusKm:  filter.RadiusKm,
	}

	if filter.Query != nil {
		params.Query = *filter.Query
	}
	if filter.Limit != nil {
		params.Limit = *filter.Limit
	} else {
		params.Limit = 20 // default
	}
	if filter.Offset != nil {
		params.Offset = *filter.Offset
	}

	// Execute search
	facilities, err := r.searchAdapter.Search(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("search failed: %w", err)
	}

	// Build result
	result := &entities.GraphQLFacilitySearchResult{
		FacilitiesData:  facilities,
		TotalCountValue: len(facilities),
		SearchTimeMs:    0, // TODO: track actual search time
		// TODO: Implement facets and pagination
		FacetsData: &entities.SearchFacets{
			FacilityTypes:      []entities.FacetCount{},
			InsuranceProviders: []entities.FacetCount{},
			Specialties:        []entities.FacetCount{},
			Cities:             []entities.FacetCount{},
			States:             []entities.FacetCount{},
			PriceRanges:        []entities.PriceRangeFacet{},
			RatingDistribution: []entities.RatingFacet{},
		},
		PaginationData: &entities.PaginationInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
			CurrentPage:     1,
			TotalPages:      1,
			Limit:           params.Limit,
			Offset:          params.Offset,
		},
	}

	return result, nil
}

// SearchFacilities is the resolver for the searchFacilities field.
func (r *queryResolver) SearchFacilities(ctx context.Context, query string, location generated.LocationInput, radiusKm *float64, filters *generated.FacilitySearchInput) (*entities.GraphQLFacilitySearchResult, error) {
	// Default radius if not provided
	radius := 10.0
	if radiusKm != nil {
		radius = *radiusKm
	}

	// Build search params
	params := repositories.SearchParams{
		Query:     query,
		Latitude:  location.Latitude,
		Longitude: location.Longitude,
		RadiusKm:  radius,
		Limit:     20,
		Offset:    0,
	}

	// Apply additional filters if provided
	if filters != nil {
		if filters.Limit != nil {
			params.Limit = *filters.Limit
		}
		if filters.Offset != nil {
			params.Offset = *filters.Offset
		}
		// Additional filter criteria could be applied here
	}

	// Execute search
	facilities, err := r.searchAdapter.Search(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("search failed: %w", err)
	}

	// Build result
	result := &entities.GraphQLFacilitySearchResult{
		FacilitiesData:  facilities,
		TotalCountValue: len(facilities),
		SearchTimeMs:    0, // TODO: track actual search time
		FacetsData: &entities.SearchFacets{
			FacilityTypes:      []entities.FacetCount{},
			InsuranceProviders: []entities.FacetCount{},
			Specialties:        []entities.FacetCount{},
			Cities:             []entities.FacetCount{},
			States:             []entities.FacetCount{},
			PriceRanges:        []entities.PriceRangeFacet{},
			RatingDistribution: []entities.RatingFacet{},
		},
		PaginationData: &entities.PaginationInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
			CurrentPage:     1,
			TotalPages:      1,
			Limit:           params.Limit,
			Offset:          params.Offset,
		},
	}

	return result, nil
}

// FacilitySuggestions is the resolver for the facilitySuggestions field.
func (r *queryResolver) FacilitySuggestions(ctx context.Context, query string, location generated.LocationInput, limit *int) ([]*generated.FacilitySuggestion, error) {
	// Default limit if not provided
	suggestionLimit := 5
	if limit != nil && *limit > 0 {
		suggestionLimit = *limit
	}

	// Build search params for suggestions
	params := repositories.SearchParams{
		Query:     query,
		Latitude:  location.Latitude,
		Longitude: location.Longitude,
		RadiusKm:  50.0, // Larger radius for suggestions
		Limit:     suggestionLimit,
		Offset:    0,
	}

	// Execute search
	facilities, err := r.searchAdapter.Search(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("suggestions search failed: %w", err)
	}

	// Convert facilities to suggestions
	suggestions := make([]*generated.FacilitySuggestion, len(facilities))
	for i, facility := range facilities {
		distance := calculateDistance(location.Latitude, location.Longitude, facility.Location.Latitude, facility.Location.Longitude)
		suggestions[i] = &generated.FacilitySuggestion{
			ID:           facility.ID,
			Name:         facility.Name,
			FacilityType: generated.FacilityType(facility.FacilityType),
			City:         facility.Address.City,
			State:        facility.Address.State,
			Distance:     &distance,
			Rating:       facility.Rating,
		}
	}

	return suggestions, nil
}

// calculateDistance calculates distance between two coordinates in kilometers
// Using haversine formula
func calculateDistance(lat1, lon1, lat2, lon2 float64) float64 {
	const R = 6371 // Earth's radius in kilometers

	dLat := (lat2 - lat1) * math.Pi / 180.0
	dLon := (lon2 - lon1) * math.Pi / 180.0

	a := math.Sin(dLat/2)*math.Sin(dLat/2) +
		math.Cos(lat1*math.Pi/180.0)*math.Cos(lat2*math.Pi/180.0)*
			math.Sin(dLon/2)*math.Sin(dLon/2)

	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

	return R * c
}

// Helper trigonometric functions
func sin2(x float64) float64 {
	s := sin(x)
	return s * s
}

func sin(x float64) float64 {
	// Simplified sine approximation - in production use math.Sin
	return x - (x*x*x)/6 + (x*x*x*x*x)/120
}

func cos(x float64) float64 {
	// Simplified cosine approximation - in production use math.Cos
	return 1 - (x*x)/2 + (x*x*x*x)/24
}

func sqrt(x float64) float64 {
	if x < 0 {
		return 0
	}
	// Newton's method approximation - in production use math.Sqrt
	z := x
	for i := 0; i < 10; i++ {
		z = (z + x/z) / 2
	}
	return z
}

func atan2(y, x float64) float64 {
	// Simplified atan2 - in production use math.Atan2
	if x > 0 {
		return atan(y / x)
	}
	if x < 0 && y >= 0 {
		return atan(y/x) + 3.14159265
	}
	if x < 0 && y < 0 {
		return atan(y/x) - 3.14159265
	}
	if x == 0 && y > 0 {
		return 3.14159265 / 2
	}
	if x == 0 && y < 0 {
		return -3.14159265 / 2
	}
	return 0
}

func atan(x float64) float64 {
	// Simplified atan approximation - in production use math.Atan
	return x - (x*x*x)/3 + (x*x*x*x*x)/5
}

// Procedure is the resolver for the procedure field.
func (r *queryResolver) Procedure(ctx context.Context, id string) (*entities.Procedure, error) {
	// Try to get as a FacilityProcedure first (which includes price/context)
	fp, err := r.facilityProcedureRepo.GetByID(ctx, id)
	if err == nil {
		p, err := r.procedureRepo.GetByID(ctx, fp.ProcedureID)
		if err != nil {
			return nil, fmt.Errorf("global procedure not found for facility procedure: %w", err)
		}
		p.FacilityID = fp.FacilityID
		p.Price = fp.Price
		p.Duration = fp.EstimatedDuration
		return p, nil
	}

	// If not found, try as a global Procedure (price/facility will be missing/error)
	p, err := r.procedureRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("procedure not found: %w", err)
	}
	return p, nil
}

// Procedures is the resolver for the procedures field.
func (r *queryResolver) Procedures(ctx context.Context, filter generated.ProcedureSearchInput) (*generated.ProcedureConnection, error) {
	if filter.FacilityID != nil {
		fps, err := r.facilityProcedureRepo.ListByFacility(ctx, *filter.FacilityID)
		if err != nil {
			return nil, fmt.Errorf("failed to list facility procedures: %w", err)
		}

		nodes := make([]*entities.Procedure, 0, len(fps))
		for _, fp := range fps {
			p, err := r.procedureRepo.GetByID(ctx, fp.ProcedureID)
			if err != nil {
				continue
			}

			// Apply category filter if present
			if filter.Category != nil && p.Category != string(*filter.Category) {
				continue
			}

			// Apply maxPrice filter if present
			if filter.MaxPrice != nil && fp.Price > *filter.MaxPrice {
				continue
			}

			p.FacilityID = fp.FacilityID
			p.Price = fp.Price
			p.Duration = fp.EstimatedDuration
			nodes = append(nodes, p)
		}

		// Basic pagination
		start := 0
		if filter.Offset != nil {
			start = *filter.Offset
		}
		if start > len(nodes) {
			start = len(nodes)
		}
		end := len(nodes)
		if filter.Limit != nil {
			end = start + *filter.Limit
			if end > len(nodes) {
				end = len(nodes)
			}
		}

		return &generated.ProcedureConnection{
			Nodes: nodes[start:end],
			PageInfo: &generated.PageInfo{
				HasNextPage:     end < len(nodes),
				HasPreviousPage: start > 0,
			},
			TotalCount: len(nodes),
		}, nil
	}

	// Fallback to global procedures if no facility specified
	repoFilter := repositories.ProcedureFilter{}
	if filter.Category != nil {
		repoFilter.Category = string(*filter.Category)
	}
	if filter.Limit != nil {
		repoFilter.Limit = *filter.Limit
	}
	if filter.Offset != nil {
		repoFilter.Offset = *filter.Offset
	}

	procs, err := r.procedureRepo.List(ctx, repoFilter)
	if err != nil {
		return nil, fmt.Errorf("failed to list global procedures: %w", err)
	}

	return &generated.ProcedureConnection{
		Nodes: procs,
		PageInfo: &generated.PageInfo{
			HasNextPage:     len(procs) == repoFilter.Limit, // Approximate
			HasPreviousPage: repoFilter.Offset > 0,
		},
		TotalCount: len(procs),
	}, nil
}

// Appointment is the resolver for the procedure field.
func (r *queryResolver) Appointment(ctx context.Context, id string) (*entities.Appointment, error) {
	appointment, err := r.appointmentRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("appointment not found: %w", err)
	}
	return appointment, nil
}

// Appointments is the resolver for the appointments field.
func (r *queryResolver) Appointments(ctx context.Context, filter generated.AppointmentSearchInput) ([]*entities.Appointment, error) {
	repoFilter := repositories.AppointmentFilter{}
	if filter.Status != nil {
		repoFilter.Status = *filter.Status
	}
	if filter.Limit != nil {
		repoFilter.Limit = *filter.Limit
	}
	if filter.Offset != nil {
		repoFilter.Offset = *filter.Offset
	}

	if filter.FacilityID != nil {
		return r.appointmentRepo.ListByFacility(ctx, *filter.FacilityID, repoFilter)
	}

	// If no facility specified, for now return empty list or could list by user if auth was present
	return []*entities.Appointment{}, nil
}

// InsuranceProvider is the resolver for the insuranceProvider field.
func (r *queryResolver) InsuranceProvider(ctx context.Context, id string) (*entities.InsuranceProvider, error) {
	return r.insuranceRepo.GetByID(ctx, id)
}

// InsuranceProviders is the resolver for the insuranceProviders field.
func (r *queryResolver) InsuranceProviders(ctx context.Context, isActive *bool, state *string, limit *int, offset *int) ([]*entities.InsuranceProvider, error) {
	filter := repositories.InsuranceFilter{
		IsActive: isActive,
	}
	if limit != nil {
		filter.Limit = *limit
	}
	if offset != nil {
		filter.Offset = *offset
	}
	return r.insuranceRepo.List(ctx, filter)
}

// FacilityStats is the resolver for the facilityStats field.
func (r *queryResolver) FacilityStats(ctx context.Context) (*generated.FacilityStats, error) {
	// Return basic stats - would calculate from database in full implementation
	return &generated.FacilityStats{
		TotalFacilities:       0,
		TotalProcedures:       0,
		AvgRating:             0.0,
		AvgWaitTime:           0,
		FacilitiesByType:      []*entities.FacetCount{},
		TopInsuranceProviders: []*entities.FacetCount{},
	}, nil
}

// PriceComparison is the resolver for the priceComparison field.
func (r *queryResolver) PriceComparison(ctx context.Context, procedureCode string, location generated.LocationInput, radiusKm float64) (*generated.PriceComparisonResult, error) {
	// Return empty result for now - would calculate from procedure prices in full implementation
	return &generated.PriceComparisonResult{
		ProcedureCode: procedureCode,
		ProcedureName: "Unknown Procedure",
		MinPrice:      0,
		MaxPrice:      0,
		AvgPrice:      0,
		Facilities:    []*generated.FacilityPriceInfo{},
	}, nil
}

// Appointment returns generated.AppointmentResolver implementation.
func (r *Resolver) Appointment() generated.AppointmentResolver { return &appointmentResolver{r} }

// Facility returns generated.FacilityResolver implementation.
func (r *Resolver) Facility() generated.FacilityResolver { return &facilityResolver{r} }

// FacilitySearchResult returns generated.FacilitySearchResultResolver implementation.
func (r *Resolver) FacilitySearchResult() generated.FacilitySearchResultResolver {
	return &facilitySearchResultResolver{r}
}

// InsuranceProvider returns generated.InsuranceProviderResolver implementation.
func (r *Resolver) InsuranceProvider() generated.InsuranceProviderResolver {
	return &insuranceProviderResolver{r}
}

// Procedure returns generated.ProcedureResolver implementation.
func (r *Resolver) Procedure() generated.ProcedureResolver { return &procedureResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type appointmentResolver struct{ *Resolver }
type facilityResolver struct{ *Resolver }
type facilitySearchResultResolver struct{ *Resolver }
type insuranceProviderResolver struct{ *Resolver }
type procedureResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
