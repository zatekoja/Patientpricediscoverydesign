import { metrics } from '@opentelemetry/api';

const meter = metrics.getMeter('patient-price-discovery-provider', '1.0.0');

const providerSyncCount = meter.createCounter('provider.sync.count', {
  description: 'Number of provider sync attempts',
});
const providerSyncDuration = meter.createHistogram('provider.sync.duration_ms', {
  description: 'Duration of provider sync operations',
  unit: 'ms',
});
const providerRecordsProcessed = meter.createCounter('provider.records.processed', {
  description: 'Number of records processed by provider syncs',
});

const schedulerRunCount = meter.createCounter('scheduler.job.run', {
  description: 'Number of scheduler job runs',
});
const schedulerSkipCount = meter.createCounter('scheduler.job.skipped', {
  description: 'Number of scheduler job runs skipped due to overlap',
});
const schedulerDuration = meter.createHistogram('scheduler.job.duration_ms', {
  description: 'Duration of scheduler job execution',
  unit: 'ms',
});

const apiRequestCount = meter.createCounter('api.request.count', {
  description: 'API request count',
});
const apiRequestDuration = meter.createHistogram('api.request.duration_ms', {
  description: 'API request duration',
  unit: 'ms',
});

const tagGenerationCount = meter.createCounter('provider.tag_generation.count', {
  description: 'Number of tag generation attempts',
});
const tagGenerationErrors = meter.createCounter('provider.tag_generation.error.count', {
  description: 'Number of tag generation errors',
});
const tagGenerationDuration = meter.createHistogram('provider.tag_generation.duration_ms', {
  description: 'Duration of tag generation per item',
  unit: 'ms',
});
const tagsGenerated = meter.createCounter('provider.tags.generated', {
  description: 'Number of tags generated by LLM provider',
});

const providerRecordsPerFacility = meter.createHistogram('provider.records.per_facility', {
  description: 'Number of records ingested per facility',
  unit: 'records',
});

const providerPriceValue = meter.createHistogram('provider.price.value', {
  description: 'Distribution of price values ingested by provider',
});

const providerPriceRange = meter.createHistogram('provider.price.range', {
  description: 'Range of price values per sync batch',
});

const providerTagCoverage = meter.createHistogram('provider.tag.coverage', {
  description: 'Ratio of records with tags present',
});

const providerMissingFieldCount = meter.createCounter('provider.missing_field.count', {
  description: 'Count of missing required fields in provider data',
});

const capacityRequestCount = meter.createCounter('provider.capacity.request.count', {
  description: 'Number of capacity update requests sent',
});
const capacityRequestErrors = meter.createCounter('provider.capacity.request.error.count', {
  description: 'Number of capacity update request failures',
});
const capacityRequestJobCount = meter.createCounter('provider.capacity.request.job.count', {
  description: 'Number of capacity request job runs',
});
const capacityRequestJobDuration = meter.createHistogram('provider.capacity.request.job.duration_ms', {
  description: 'Duration of capacity request job execution',
  unit: 'ms',
});
const capacityTokenIssued = meter.createCounter('provider.capacity.token.issued', {
  description: 'Number of capacity update tokens issued',
});
const capacityTokenConsumed = meter.createCounter('provider.capacity.token.consumed', {
  description: 'Number of capacity update tokens consumed',
});
const capacityUpdateCount = meter.createCounter('provider.capacity.update.count', {
  description: 'Number of capacity updates applied',
});
const capacityUpdateErrors = meter.createCounter('provider.capacity.update.error.count', {
  description: 'Number of failed capacity updates',
});
const capacityWebhookCount = meter.createCounter('provider.capacity.webhook.count', {
  description: 'Number of ingestion webhook calls after capacity update',
});
const capacityWebhookErrors = meter.createCounter('provider.capacity.webhook.error.count', {
  description: 'Number of ingestion webhook call failures',
});
const facilityProfileCreated = meter.createCounter('provider.facility.profile.created', {
  description: 'Number of facility profiles created',
});
const facilityProfileSkipped = meter.createCounter('provider.facility.profile.skipped', {
  description: 'Number of facility profiles skipped (already exists)',
});
const facilityProfileFailed = meter.createCounter('provider.facility.profile.failed', {
  description: 'Number of facility profile enrich failures',
});
const facilityProfileLLMCount = meter.createCounter('provider.facility.profile.llm.count', {
  description: 'Number of facility profile LLM enrichment attempts',
});
const facilityProfileLLMErrors = meter.createCounter('provider.facility.profile.llm.error.count', {
  description: 'Number of facility profile LLM errors',
});
const facilityProfileLLMDuration = meter.createHistogram('provider.facility.profile.llm.duration_ms', {
  description: 'Duration of facility profile LLM calls',
  unit: 'ms',
});
const facilityProfileLLMTags = meter.createCounter('provider.facility.profile.llm.tags', {
  description: 'Number of tags returned by facility profile LLM',
});

const procedureProfileCreated = meter.createCounter('provider.procedure.profile.created', {
  description: 'Number of procedure profiles created',
});
const procedureProfileSkipped = meter.createCounter('provider.procedure.profile.skipped', {
  description: 'Number of procedure profiles skipped (already exists)',
});
const procedureProfileFailed = meter.createCounter('provider.procedure.profile.failed', {
  description: 'Number of procedure profile enrich failures',
});
const procedureProfileLLMCount = meter.createCounter('provider.procedure.profile.llm.count', {
  description: 'Number of procedure profile LLM enrichment attempts',
});
const procedureProfileLLMErrors = meter.createCounter('provider.procedure.profile.llm.error.count', {
  description: 'Number of procedure profile LLM errors',
});
const procedureProfileLLMDuration = meter.createHistogram('provider.procedure.profile.llm.duration_ms', {
  description: 'Duration of procedure profile LLM calls',
  unit: 'ms',
});
const procedureProfileLLMTags = meter.createCounter('provider.procedure.profile.llm.tags', {
  description: 'Number of tags returned by procedure profile LLM',
});

type ProviderSyncState = {
  lastSyncMs?: number;
};

const providerSyncState = new Map<string, ProviderSyncState>();

const providerLastSyncAgeSeconds = meter.createObservableGauge('provider.last_sync_age_seconds', {
  description: 'Seconds since the last successful provider sync',
});

const providerDataFreshnessDays = meter.createObservableGauge('provider.data.freshness_days', {
  description: 'Days since the last successful provider sync',
});

providerLastSyncAgeSeconds.addCallback((observableResult) => {
  const now = Date.now();
  for (const [provider, state] of providerSyncState.entries()) {
    if (!state.lastSyncMs) {
      continue;
    }
    const ageSeconds = Math.max(0, (now - state.lastSyncMs) / 1000);
    observableResult.observe(ageSeconds, { provider });
  }
});

providerDataFreshnessDays.addCallback((observableResult) => {
  const now = Date.now();
  for (const [provider, state] of providerSyncState.entries()) {
    if (!state.lastSyncMs) {
      continue;
    }
    const ageDays = Math.max(0, (now - state.lastSyncMs) / (1000 * 60 * 60 * 24));
    observableResult.observe(ageDays, { provider });
  }
});

export function recordProviderSyncMetrics(params: {
  provider: string;
  success: boolean;
  recordsProcessed: number;
  durationMs: number;
  timestamp?: Date;
}): void {
  providerSyncCount.add(1, { provider: params.provider, success: String(params.success) });
  providerSyncDuration.record(params.durationMs, { provider: params.provider });
  providerRecordsProcessed.add(params.recordsProcessed, { provider: params.provider });
  if (params.success) {
    const ts = params.timestamp ? params.timestamp.getTime() : Date.now();
    providerSyncState.set(params.provider, { lastSyncMs: ts });
  }
}

export function recordSchedulerRun(params: {
  job: string;
  success?: boolean;
  durationMs?: number;
}): void {
  schedulerRunCount.add(1, {
    job: params.job,
    success: params.success === undefined ? 'unknown' : String(params.success),
  });
  if (params.durationMs !== undefined) {
    schedulerDuration.record(params.durationMs, { job: params.job });
  }
}

export function recordSchedulerSkip(job: string): void {
  schedulerSkipCount.add(1, { job });
}

export function recordApiRequest(params: {
  method: string;
  path: string;
  status: number;
  durationMs: number;
}): void {
  apiRequestCount.add(1, {
    method: params.method,
    path: params.path,
    status: params.status,
  });
  apiRequestDuration.record(params.durationMs, {
    method: params.method,
    path: params.path,
    status: params.status,
  });
}

export function recordTagGeneration(params: {
  provider: string;
  durationMs: number;
  tags: number;
  success: boolean;
}): void {
  tagGenerationCount.add(1, { provider: params.provider, success: String(params.success) });
  tagGenerationDuration.record(params.durationMs, { provider: params.provider });
  if (params.tags > 0) {
    tagsGenerated.add(params.tags, { provider: params.provider });
  }
  if (!params.success) {
    tagGenerationErrors.add(1, { provider: params.provider });
  }
}

export interface ProviderRecordLike {
  facilityName?: string;
  procedureCode?: string;
  procedureDescription?: string;
  price?: number;
  currency?: string;
  effectiveDate?: Date | string;
  tags?: string[];
}

export function recordProviderDataMetrics(params: {
  provider: string;
  records: ProviderRecordLike[];
}): void {
  const { provider, records } = params;
  if (!records || records.length === 0) {
    return;
  }

  const facilityCounts = new Map<string, number>();
  const missingFieldCounts: Record<string, number> = {
    facilityName: 0,
    procedureCode: 0,
    procedureDescription: 0,
    price: 0,
    effectiveDate: 0,
  };

  let taggedCount = 0;
  let minPrice: number | null = null;
  let maxPrice: number | null = null;

  for (const record of records) {
    const facilityName = (record.facilityName || '').trim();
    if (!facilityName) {
      missingFieldCounts.facilityName += 1;
    } else {
      facilityCounts.set(facilityName, (facilityCounts.get(facilityName) || 0) + 1);
    }

    if (!record.procedureCode || String(record.procedureCode).trim().length === 0) {
      missingFieldCounts.procedureCode += 1;
    }
    if (!record.procedureDescription || String(record.procedureDescription).trim().length === 0) {
      missingFieldCounts.procedureDescription += 1;
    }

    const price = typeof record.price === 'number' ? record.price : Number(record.price);
    if (!Number.isFinite(price)) {
      missingFieldCounts.price += 1;
    } else {
      const currency = record.currency || 'unknown';
      providerPriceValue.record(price, { provider, currency });
      if (minPrice === null || price < minPrice) {
        minPrice = price;
      }
      if (maxPrice === null || price > maxPrice) {
        maxPrice = price;
      }
    }

    const effectiveDate = record.effectiveDate;
    if (!effectiveDate) {
      missingFieldCounts.effectiveDate += 1;
    } else {
      const parsed =
        effectiveDate instanceof Date ? effectiveDate : new Date(effectiveDate);
      if (Number.isNaN(parsed.getTime())) {
        missingFieldCounts.effectiveDate += 1;
      }
    }

    if (record.tags && record.tags.length > 0) {
      taggedCount += 1;
    }
  }

  for (const [facility, count] of facilityCounts.entries()) {
    providerRecordsPerFacility.record(count, { provider, facility });
  }

  const tagCoverage = taggedCount / records.length;
  providerTagCoverage.record(tagCoverage, { provider });

  for (const [field, count] of Object.entries(missingFieldCounts)) {
    if (count > 0) {
      providerMissingFieldCount.add(count, { provider, field });
    }
  }

  if (minPrice !== null && maxPrice !== null) {
    const currency = records.find((record) => record.currency)?.currency || 'unknown';
    providerPriceRange.record(maxPrice - minPrice, { provider, currency });
  }
}

export function recordCapacityRequest(params: { channel: string; success: boolean }): void {
  capacityRequestCount.add(1, { channel: params.channel, success: String(params.success) });
  if (!params.success) {
    capacityRequestErrors.add(1, { channel: params.channel });
  }
}

export function recordCapacityRequestJob(params: { success?: boolean; durationMs?: number }): void {
  capacityRequestJobCount.add(1, {
    success: params.success === undefined ? 'unknown' : String(params.success),
  });
  if (params.durationMs !== undefined) {
    capacityRequestJobDuration.record(params.durationMs);
  }
}

export function recordCapacityTokenIssued(channel: string): void {
  capacityTokenIssued.add(1, { channel });
}

export function recordCapacityTokenConsumed(channel: string): void {
  capacityTokenConsumed.add(1, { channel });
}

export function recordCapacityUpdate(params: { source: string; success: boolean }): void {
  capacityUpdateCount.add(1, { source: params.source, success: String(params.success) });
  if (!params.success) {
    capacityUpdateErrors.add(1, { source: params.source });
  }
}

export function recordCapacityWebhook(params: { success: boolean }): void {
  capacityWebhookCount.add(1, { success: String(params.success) });
  if (!params.success) {
    capacityWebhookErrors.add(1, {});
  }
}

export function recordFacilityProfileEnrichment(params: {
  provider: string;
  created: number;
  skipped: number;
  failed: number;
}): void {
  if (params.created > 0) {
    facilityProfileCreated.add(params.created, { provider: params.provider });
  }
  if (params.skipped > 0) {
    facilityProfileSkipped.add(params.skipped, { provider: params.provider });
  }
  if (params.failed > 0) {
    facilityProfileFailed.add(params.failed, { provider: params.provider });
  }
}

export function recordFacilityProfileLLM(params: {
  provider: string;
  success: boolean;
  durationMs: number;
  tags?: number;
}): void {
  facilityProfileLLMCount.add(1, { provider: params.provider, success: String(params.success) });
  facilityProfileLLMDuration.record(params.durationMs, { provider: params.provider });
  if (!params.success) {
    facilityProfileLLMErrors.add(1, { provider: params.provider });
  }
  if (params.tags && params.tags > 0) {
    facilityProfileLLMTags.add(params.tags, { provider: params.provider });
  }
}

export function recordProcedureProfileEnrichment(params: {
  provider: string;
  created: number;
  skipped: number;
  failed: number;
}): void {
  if (params.created > 0) {
    procedureProfileCreated.add(params.created, { provider: params.provider });
  }
  if (params.skipped > 0) {
    procedureProfileSkipped.add(params.skipped, { provider: params.provider });
  }
  if (params.failed > 0) {
    procedureProfileFailed.add(params.failed, { provider: params.provider });
  }
}

export function recordProcedureProfileLLM(params: {
  provider: string;
  success: boolean;
  durationMs: number;
  tags?: number;
}): void {
  procedureProfileLLMCount.add(1, { provider: params.provider, success: String(params.success) });
  procedureProfileLLMDuration.record(params.durationMs, { provider: params.provider });
  if (!params.success) {
    procedureProfileLLMErrors.add(1, { provider: params.provider });
  }
  if (params.tags && params.tags > 0) {
    procedureProfileLLMTags.add(params.tags, { provider: params.provider });
  }
}
