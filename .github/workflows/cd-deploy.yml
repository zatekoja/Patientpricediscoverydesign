name: "CD - Deploy to AWS"

# This workflow handles deployments to AWS
# It runs AFTER CI passes on main branch merges or manual trigger
# Supports deployment to dev, staging, and prod environments

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        default: 'dev'
        type: string
      deployment-type:
        description: 'Deployment type'
        required: false
        default: 'auto'
        type: string
      skip-approval:
        description: 'Skip manual approval (dev only)'
        required: false
        default: false
        type: boolean
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      deployment-type:
        description: 'Deployment type'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto                    # Auto-detect what changed
          - backend-only           # Deploy only backend services
          - frontend-only          # Deploy only frontend
          - infrastructure-only    # Deploy only infrastructure
          - full                   # Deploy everything
      skip-approval:
        description: 'Skip manual approval (dev only)'
        required: false
        default: false
        type: boolean

# Prevent concurrent deployments to same environment
concurrency:
  group: cd-${{ inputs.environment || 'dev' }}
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write

env:
  GO_VERSION: '1.25.0'
  NODE_VERSION: '18'
  AWS_REGION: 'eu-west-1'
  DOMAIN: 'ateru.ng'

jobs:
  # ==========================================
  # Phase 1: Determine Deployment Plan
  # ==========================================
  plan-deployment:
    name: "ðŸ“‹ Plan Deployment"
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.plan.outputs.environment }}
      deploy-infrastructure: ${{ steps.plan.outputs.deploy-infrastructure }}
      deploy-backend: ${{ steps.plan.outputs.deploy-backend }}
      deploy-frontend: ${{ steps.plan.outputs.deploy-frontend }}
      needs-approval: ${{ steps.plan.outputs.needs-approval }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Plan deployment
        id: plan
        run: |
          # Determine environment
          ENV="${{ inputs.environment }}"
          if [ -z "$ENV" ]; then
            ENV="dev"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT

          # Determine what to deploy
          DEPLOY_TYPE="${{ inputs.deployment-type }}"
          if [ "$DEPLOY_TYPE" = "auto" ]; then
            # Auto-detect changes
            if git diff --name-only HEAD~1 | grep -q '^backend/'; then
              echo "deploy-backend=true" >> $GITHUB_OUTPUT
            else
              echo "deploy-backend=false" >> $GITHUB_OUTPUT
            fi
            
            if git diff --name-only HEAD~1 | grep -q '^Frontend/\|^package\.json\|^tsconfig\.json'; then
              echo "deploy-frontend=true" >> $GITHUB_OUTPUT
            else
              echo "deploy-frontend=false" >> $GITHUB_OUTPUT
            fi
            
            if git diff --name-only HEAD~1 | grep -q '^infrastructure/\|^terraform/'; then
              echo "deploy-infrastructure=true" >> $GITHUB_OUTPUT
            else
              echo "deploy-infrastructure=false" >> $GITHUB_OUTPUT
            fi
          else
            # Manual deployment type selection
            case "$DEPLOY_TYPE" in
              "backend-only")
                echo "deploy-backend=true" >> $GITHUB_OUTPUT
                echo "deploy-frontend=false" >> $GITHUB_OUTPUT
                echo "deploy-infrastructure=false" >> $GITHUB_OUTPUT
                ;;
              "frontend-only")
                echo "deploy-backend=false" >> $GITHUB_OUTPUT
                echo "deploy-frontend=true" >> $GITHUB_OUTPUT
                echo "deploy-infrastructure=false" >> $GITHUB_OUTPUT
                ;;
              "infrastructure-only")
                echo "deploy-backend=false" >> $GITHUB_OUTPUT
                echo "deploy-frontend=false" >> $GITHUB_OUTPUT
                echo "deploy-infrastructure=true" >> $GITHUB_OUTPUT
                ;;
              "full")
                echo "deploy-backend=true" >> $GITHUB_OUTPUT
                echo "deploy-frontend=true" >> $GITHUB_OUTPUT
                echo "deploy-infrastructure=true" >> $GITHUB_OUTPUT
                ;;
            esac
          fi

          # Determine if approval is needed
          if [ "$ENV" = "dev" ] && [ "${{ inputs.skip-approval }}" = "true" ]; then
            echo "needs-approval=false" >> $GITHUB_OUTPUT
          elif [ "$ENV" = "dev" ]; then
            echo "needs-approval=false" >> $GITHUB_OUTPUT
          else
            echo "needs-approval=true" >> $GITHUB_OUTPUT
          fi

          echo "ðŸ“‹ Deployment Plan:"
          echo "Environment: $ENV"
          echo "Infrastructure: $([ "$(cat $GITHUB_OUTPUT | grep deploy-infrastructure | cut -d= -f2)" = "true" ] && echo "âœ…" || echo "âŒ")"
          echo "Backend: $([ "$(cat $GITHUB_OUTPUT | grep deploy-backend | cut -d= -f2)" = "true" ] && echo "âœ…" || echo "âŒ")"
          echo "Frontend: $([ "$(cat $GITHUB_OUTPUT | grep deploy-frontend | cut -d= -f2)" = "true" ] && echo "âœ…" || echo "âŒ")"

  # ==========================================
  # Phase 2: Manual Approval (if needed)
  # ==========================================
  approval:
    name: "ðŸ›¡ï¸ Manual Approval"
    runs-on: ubuntu-latest
    needs: [plan-deployment]
    if: needs.plan-deployment.outputs.needs-approval == 'true'
    environment:
      name: ${{ needs.plan-deployment.outputs.environment }}
      url: https://${{ needs.plan-deployment.outputs.environment == 'prod' && '' || format('{0}.', needs.plan-deployment.outputs.environment) }}${{ env.DOMAIN }}

    steps:
      - name: Wait for approval
        run: |
          echo "â³ Waiting for manual approval for ${{ needs.plan-deployment.outputs.environment }} deployment..."
          echo "This deployment will affect:"
          echo "- Infrastructure: ${{ needs.plan-deployment.outputs.deploy-infrastructure }}"
          echo "- Backend: ${{ needs.plan-deployment.outputs.deploy-backend }}"
          echo "- Frontend: ${{ needs.plan-deployment.outputs.deploy-frontend }}"

  # ==========================================
  # Phase 3: Infrastructure Deployment
  # ==========================================
  deploy-infrastructure:
    name: "ðŸ—ï¸ Deploy Infrastructure"
    runs-on: ubuntu-latest
    needs: [plan-deployment, approval]
    if: always() && (needs.approval.result == 'success' || needs.approval.result == 'skipped') && needs.plan-deployment.outputs.deploy-infrastructure == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/GitHubActionsDeployRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Pulumi
        uses: pulumi/actions@v4
        with:
          pulumi-version: '^3.0.0'

      - name: Deploy Pulumi infrastructure
        working-directory: infrastructure/pulumi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          echo "ðŸ—ï¸ Deploying infrastructure to ${{ needs.plan-deployment.outputs.environment }}..."
          npm ci
          # Select stack based on environment
          pulumi stack select ${{ needs.plan-deployment.outputs.environment }}
          pulumi up --yes --skip-preview
          echo "âœ… Infrastructure deployment completed"

  # ==========================================
  # Phase 4: Backend Deployment
  # ==========================================
  deploy-backend:
    name: "ðŸš€ Deploy Backend"
    runs-on: ubuntu-latest
    needs: [plan-deployment, approval, deploy-infrastructure]
    if: always() && (needs.approval.result == 'success' || needs.approval.result == 'skipped') && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') && needs.plan-deployment.outputs.deploy-backend == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go and Generate code
        uses: ./.github/actions/setup-service-go
        with:
          working-directory: backend
          go-version: ${{ env.GO_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/GitHubActionsDeployRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker images
        working-directory: backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ needs.plan-deployment.outputs.environment }}
        run: |
          echo "ðŸ³ Building and pushing backend services..."
          
          # Helper function to build and push
          build_and_push() {
            local service=$1
            local dockerfile=$2
            local repo_name="ohi-${ENVIRONMENT}-${service}"
            local image="$ECR_REGISTRY/$repo_name:$IMAGE_TAG"
            
            echo "Building $service from $dockerfile..."
            docker build -f "$dockerfile" -t "$image" .
            docker tag "$image" "$ECR_REGISTRY/$repo_name:latest"
            docker push "$image"
            docker push "$ECR_REGISTRY/$repo_name:latest"
            echo "âœ… Pushed $image"
          }
          
          # Build all backend services
          [ -f "Dockerfile" ] && build_and_push "api" "Dockerfile"
          [ -f "Dockerfile.provider" ] && build_and_push "provider-api" "Dockerfile.provider"
          [ -f "Dockerfile.graphql-server" ] && build_and_push "graphql" "Dockerfile.graphql-server"
          [ -f "Dockerfile.sse-server" ] && build_and_push "sse" "Dockerfile.sse-server"
          [ -f "Dockerfile.indexer" ] && build_and_push "reindexer" "Dockerfile.indexer"
          [ -f "blnk.Dockerfile" ] && build_and_push "blnk-api" "blnk.Dockerfile"
          
          echo "âœ… All backend images built and pushed"

      - name: Run database migrations
        run: |
          echo "ðŸ—„ï¸ Running database migrations..."
          chmod +x ./scripts/run-migrations.sh
          ./scripts/run-migrations.sh ${{ needs.plan-deployment.outputs.environment }} up
          echo "âœ… Database migrations completed"

      - name: Deploy to ECS
        env:
          ENVIRONMENT: ${{ needs.plan-deployment.outputs.environment }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "â˜ï¸ Deploying backend services to ECS..."
          chmod +x ./scripts/deploy-ecs.sh
          
          # Deploy each service
          for service in api graphql sse provider-api reindexer; do
            echo "Deploying $service..."
            ./scripts/deploy-ecs.sh $ENVIRONMENT $service $IMAGE_TAG
          done
          
          echo "âœ… All backend services deployed"

  # ==========================================
  # Phase 5: Frontend Deployment
  # ==========================================
  deploy-frontend:
    name: "ðŸŒ Deploy Frontend"
    runs-on: ubuntu-latest
    needs: [plan-deployment, approval, deploy-infrastructure, deploy-backend]
    if: always() && (needs.approval.result == 'success' || needs.approval.result == 'skipped') && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') && needs.plan-deployment.outputs.deploy-frontend == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js and build frontend
        uses: ./.github/actions/setup-service-typescript
        with:
          working-directory: .
          node-version: ${{ env.NODE_VERSION }}
          cache-dependency-path: package-lock.json

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/GitHubActionsDeployRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Fetch frontend secrets
        id: fetch-secrets
        run: |
          echo "ðŸ” Fetching secrets from AWS Secrets Manager..."
          ENV="${{ needs.plan-deployment.outputs.environment }}"
          SECRET_NAME="ohi-$ENV-geolocation-api-key"
          
          # Fetch secret value (suppress output)
          GEO_KEY=$(aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" --query SecretString --output text || echo "")
          
          if [ -z "$GEO_KEY" ]; then
            echo "âš ï¸ Warning: Could not fetch $SECRET_NAME. Map features may not work."
          else
            echo "::add-mask::$GEO_KEY"
            echo "VITE_GEOLOCATION_API_KEY=$GEO_KEY" >> $GITHUB_ENV
            echo "âœ… Fetched geolocation API key"
          fi

      - name: Build frontend for production
        working-directory: .
        run: |
          echo "ðŸ”¨ Building frontend for ${{ needs.plan-deployment.outputs.environment }}..."
          
          # Set environment variables for build
          ENV="${{ needs.plan-deployment.outputs.environment }}"
          if [ "$ENV" = "prod" ]; then
            API_URL="https://api.${{ env.DOMAIN }}"
            FRONTEND_URL="https://${{ env.DOMAIN }}"
          else
            API_URL="https://api.$ENV.${{ env.DOMAIN }}"
            FRONTEND_URL="https://$ENV.${{ env.DOMAIN }}"
          fi
          
          export VITE_API_URL=$API_URL
          export VITE_ENVIRONMENT=$ENV
          # VITE_GEOLOCATION_API_KEY is already in env from previous step
          
          npm run build
          echo "âœ… Frontend built successfully"

      - name: Deploy to S3 and Invalidate CloudFront
        working-directory: .
        env:
          ENVIRONMENT: ${{ needs.plan-deployment.outputs.environment }}
        run: |
          echo "â˜ï¸ Deploying frontend to S3 and CloudFront..."
          chmod +x ./scripts/deploy-frontend.sh
          ./scripts/deploy-frontend.sh $ENVIRONMENT
          echo "âœ… Frontend deployment completed"

  # ==========================================
  # Phase 6: Deployment Summary
  # ==========================================
  deployment-summary:
    name: "ðŸ“Š Deployment Summary"
    runs-on: ubuntu-latest
    needs: [plan-deployment, deploy-infrastructure, deploy-backend, deploy-frontend]
    if: always()

    steps:
      - name: Generate deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary - Patient Price Discovery Design" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          ENV="${{ needs.plan-deployment.outputs.environment }}"
          echo "### Environment: **$ENV**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # URLs
          if [ "$ENV" = "prod" ]; then
            echo "ðŸŒ **Frontend URL:** https://${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ”— **API URL:** https://api.${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸŒ **Frontend URL:** https://$ENV.${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ”— **API URL:** https://api.$ENV.${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Deployment status
          echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          INFRA="${{ needs.deploy-infrastructure.result }}"
          BACKEND="${{ needs.deploy-backend.result }}"
          FRONTEND="${{ needs.deploy-frontend.result }}"
          
          display_status() {
            case "$1" in
              "success") echo "âœ… **$2:** Deployed successfully" ;;
              "skipped") echo "â­ï¸ **$2:** Skipped (no changes)" ;;
              "failure") echo "âŒ **$2:** Deployment failed" ;;
              *) echo "âš ï¸ **$2:** Unknown status" ;;
            esac
          }
          
          display_status "$INFRA" "Infrastructure" >> $GITHUB_STEP_SUMMARY
          display_status "$BACKEND" "Backend Services" >> $GITHUB_STEP_SUMMARY
          display_status "$FRONTEND" "Frontend Application" >> $GITHUB_STEP_SUMMARY
          
          # Overall status
          if [[ "$INFRA" == "failure" ]] || [[ "$BACKEND" == "failure" ]] || [[ "$FRONTEND" == "failure" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### âŒ DEPLOYMENT: FAILED" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### âœ… DEPLOYMENT: SUCCESS" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**AWS Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY