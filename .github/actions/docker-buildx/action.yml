name: 'Docker Buildx Build'
description: 'Build Docker images using buildx with local caching and optional registry push'
author: 'P2PBets Team'

inputs:
  context:
    description: 'Build context path (e.g., Backend or Backend/Services)'
    required: true
  dockerfile:
    description: 'Path to Dockerfile relative to repository root'
    required: true
  image-tag:
    description: 'Image tag to apply (e.g., service-name or full registry path)'
    required: true
  build-args:
    description: 'Build arguments as multi-line string (e.g., "SERVICE_NAME=foo\nENVIRONMENT=dev")'
    required: false
    default: ''
  platform:
    description: 'Target platform(s) for multi-arch builds (e.g., linux/amd64,linux/arm64)'
    required: false
    default: 'linux/amd64'
  cache-key:
    description: 'Cache key for buildx cache directory (defaults to image-tag if not provided)'
    required: false
    default: ''
  push:
    description: 'Push image to registry after build (requires registry login beforehand)'
    required: false
    default: 'false'
  load:
    description: 'Load image into local Docker daemon (cannot be used with push=true for multi-platform)'
    required: false
    default: 'true'
  labels:
    description: 'Image labels as multi-line string (e.g., "org.opencontainers.image.created=$DATE")'
    required: false
    default: ''
  cache-mode:
    description: 'Cache export mode (min or max)'
    required: false
    default: 'max'
  go-version:
    description: 'Go version to use for code generation'
    required: false
    default: '1.24'

outputs:
  image-tag:
    description: 'The image tag that was built'
    value: ${{ steps.build.outputs.image-tag }}
  image-digest:
    description: 'Image digest (sha256) from build metadata'
    value: ${{ steps.build.outputs.digest }}
  cache-hit:
    description: 'Whether cache was used effectively'
    value: ${{ steps.build.outputs.cache-hit }}

runs:
  using: 'composite'
  steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container

    - name: Prepare cache directory
      shell: bash
      run: |
        CACHE_KEY="${{ inputs.cache-key }}"
        if [ -z "$CACHE_KEY" ]; then
          # Default to a sanitized version of image-tag
          CACHE_KEY=$(echo "${{ inputs.image-tag }}" | sed 's/[^a-zA-Z0-9_-]/_/g')
        fi
        
        CACHE_DIR=".github/.docker-cache/${CACHE_KEY}"
        mkdir -p "$CACHE_DIR"
        
        echo "cache-dir=$CACHE_DIR" >> $GITHUB_OUTPUT
        echo "ğŸ“¦ Using cache directory: $CACHE_DIR"
      id: cache-setup

    - name: Validate inputs
      shell: bash
      run: |
        echo "ğŸ” Validating build configuration..."
        
        if [ ! -f "${{ inputs.dockerfile }}" ]; then
          echo "âŒ Dockerfile not found: ${{ inputs.dockerfile }}"
          exit 1
        fi
        
        if [ ! -d "${{ inputs.context }}" ]; then
          echo "âŒ Build context not found: ${{ inputs.context }}"
          exit 1
        fi
        
        if [ "${{ inputs.push }}" == "true" ] && [ "${{ inputs.load }}" == "true" ]; then
          echo "âš ï¸ Warning: Both push and load are true. For multi-platform builds, only push will work."
        fi
        
        echo "âœ… Build configuration validated"
        echo "  ğŸ“ Context: ${{ inputs.context }}"
        echo "  ğŸ³ Dockerfile: ${{ inputs.dockerfile }}"
        echo "  ğŸ·ï¸ Tag: ${{ inputs.image-tag }}"
        echo "  ğŸ–¥ï¸ Platform: ${{ inputs.platform }}"

    - name: Setup Go and Generate mocks/gqlgen code
      uses: ./.github/actions/setup-service-go
      with:
        go-version: ${{ inputs.go-version }}
        working-directory: Backend/Services

    - name: Build Docker image
      id: build
      shell: bash
      env:
        DOCKER_BUILDKIT: 1
      run: |
        echo "ğŸ”¨ Building Docker image with buildx..."
        
        CACHE_DIR="${{ steps.cache-setup.outputs.cache-dir }}"
        BUILD_ARGS=""
        
        # Process build arguments
        if [ -n "${{ inputs.build-args }}" ]; then
          while IFS= read -r arg; do
            if [ -n "$arg" ]; then
              BUILD_ARGS="$BUILD_ARGS --build-arg $arg"
            fi
          done <<< "${{ inputs.build-args }}"
        fi
        
        # Process labels
        LABEL_ARGS=""
        if [ -n "${{ inputs.labels }}" ]; then
          while IFS= read -r label; do
            if [ -n "$label" ]; then
              LABEL_ARGS="$LABEL_ARGS --label $label"
            fi
          done <<< "${{ inputs.labels }}"
        fi
        
        # Determine output flags
        OUTPUT_FLAG=""
        if [ "${{ inputs.push }}" == "true" ]; then
          OUTPUT_FLAG="--push"
          echo "ğŸ“¤ Push mode: Will push to registry"
        elif [ "${{ inputs.load }}" == "true" ]; then
          OUTPUT_FLAG="--load"
          echo "ğŸ’¾ Load mode: Will load into local Docker daemon"
        else
          echo "âš ï¸ Neither push nor load specified, image will not be exported"
        fi
        
        # Build command using array to properly handle arguments
        BUILD_CMD=(
          docker buildx build
          --platform "${{ inputs.platform }}"
          --file "${{ inputs.dockerfile }}"
          --tag "${{ inputs.image-tag }}"
          --cache-from "type=local,src=$CACHE_DIR"
          --cache-to "type=local,dest=$CACHE_DIR,mode=${{ inputs.cache-mode }}"
        )

        # Add build args if present
        if [ -n "$BUILD_ARGS" ]; then
          while IFS= read -r arg; do
            if [ -n "$arg" ]; then
              BUILD_CMD+=(--build-arg "$arg")
            fi
          done <<< "${{ inputs.build-args }}"
        fi

        # Add labels if present
        if [ -n "$LABEL_ARGS" ]; then
          while IFS= read -r label; do
            if [ -n "$label" ]; then
              BUILD_CMD+=(--label "$label")
            fi
          done <<< "${{ inputs.labels }}"
        fi

        # Add output flag if present
        if [ -n "$OUTPUT_FLAG" ]; then
          BUILD_CMD+=("$OUTPUT_FLAG")
        fi

        # Add context
        BUILD_CMD+=("${{ inputs.context }}")

        # Execute the build
        "${BUILD_CMD[@]}"
        BUILD_EXIT_CODE=$?
        
        if [ $BUILD_EXIT_CODE -eq 0 ]; then
          echo "âœ… Successfully built: ${{ inputs.image-tag }}"
          echo "image-tag=${{ inputs.image-tag }}" >> $GITHUB_OUTPUT
          echo "cache-hit=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Build failed with exit code: $BUILD_EXIT_CODE"
          exit $BUILD_EXIT_CODE
        fi

